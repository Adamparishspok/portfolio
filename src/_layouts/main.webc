<!DOCTYPE html>
<html lang="en" class="scroll-smooth" color-scheme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#08090A" />
    <meta name="author" content="Adam Parish" />
    <link rel="canonical" :href="base.domain + page.url" />

    <!--- Preconnect to critical third-party origins --->
    <link rel="preconnect" href="https://us.i.posthog.com" crossorigin />
    <link rel="preconnect" href="https://assets.unicorn.studio" />
    <link rel="preconnect" href="https://tr.lfeeder.com" />
    <link rel="preconnect" href="https://unpkg.com" />
    <link rel="dns-prefetch" href="https://www.googletagmanager.com" />

    <!--- Preload Fonts --->
    <link
      rel="preload"
      href="/assets/fonts/Geist-Variable.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="/assets/fonts/GeistMono-Variable.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />

    <!--- Search + Tab --->
    <title @html="this.seoTitle"></title>
    <meta name="description" :content="this.seoDesc" />

    <!--- OpenGraph --->
    <meta property="og:site_name" :content="base.name" />
    <meta property="og:type" content="website" />
    <meta property="og:title" :content="this.ogTitle" />
    <meta property="og:description" :content="this.ogDesc" />
    <meta property="og:url" :content="base.url + page.url" />
    <meta property="og:image" :content="base.url + this.ogImage" />
    <meta property="og:image:alt" :content="this.ogImageAlt || this.seoTitle" />

    <!--- Twitter --->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" :content="base.twitterHandle" />
    <meta name="twitter:creator" :content="base.twitterHandle" />

    <!--- Prevent Indexing --->
    <meta webc:if="this.noindex" name="robots" content="noindex, nofollow" />

    <script type="application/ld+json" webc:keep>
      {
        "@context": "https://schema.org",
        "@type": "Person",
        "name": "Adam Parish",
        "url": "https://atomparish.com",
        "sameAs": [
          "https://twitter.com/atomparish1",
          "https://www.linkedin.com/in/atomizer/",
          "https://dribbble.com/atomparish/",
          "https://github.com/atompariskspok"
        ],
        "jobTitle": "Lead Product Designer",
        "worksFor": {
          "@type": "Organization",
          "name": "Atomic FI"
        }
      }
    </script>

    <script>
      (function (ss, ex) {
        window.ldfdr =
          window.ldfdr ||
          function () {
            (ldfdr._q = ldfdr._q || []).push([].slice.call(arguments));
          };
        (function (d, s) {
          fs = d.getElementsByTagName(s)[0];
          function ce(src) {
            var cs = d.createElement(s);
            cs.src = src;
            cs.async = 1;
            fs.parentNode.insertBefore(cs, fs);
          }
          ce('https://sc.lfeeder.com/lftracker_v1_' + ss + (ex ? '_' + ex : '') + '.js');
        })(document, 'script');
      })('ywVkO4XmPpzaZ6Bj');
    </script>

    <!--- Light/Dark Mode: Set from localStorage or system preference --->
    <script webc:keep>
      (function () {
        const scheme =
          localStorage.getItem('scheme') ||
          (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        document.documentElement.setAttribute('color-scheme', scheme);
      })();
    </script>

    <!--- Fonts --->
    <style>
      :root {
        font-family:
          'Geist Sans', 'ui-sans-serif', 'system-ui', 'sans-serif', 'Apple Color Emoji',
          'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
        font-weight: 400;
        -webkit-font-smoothing: antialiased;
      }
    </style>

    <!--- Styles --->
    <link rel="stylesheet" href="/assets/css/main.css" webc:keep />
    <link webc:if="markdown" rel="stylesheet" href="/assets/css/markdown.css" webc:keep />
    <style @raw="getBundle('css')" webc:keep></style>

    <!--- Icons --->
    <link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <link rel="shortcut icon" href="/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-title" content="Adam P" />
    <link rel="manifest" href="/site.webmanifest" />

    <!--- PostHog - Deferred for performance --->
    <script defer webc:keep src="/assets/js/posthog.min.js"></script>
    <script defer>
      // Defer scripts execute after DOM parsing, so no DOMContentLoaded wrapper needed
      if (window.posthog) {
        window.posthog.init('phc_PVCwdgCGgAV76xJR6eA2DxTEwiqejQpFaUyz4oo8ltz', {
          api_host: 'https://us.i.posthog.com',
          person_profiles: 'identified_only',
          // Disable heavy features not needed
          disable_session_recording: false,
          disable_surveys: true,
          autocapture: false,
          capture_pageview: false,
          capture_pageleave: false,
        });
        // Send initial page load event
        window.posthog.capture('website_loaded', {
          page_url: window.location.href,
          timestamp: new Date().toISOString(),
        });
      }
    </script>
    <!--- Portfolio Analytics - Deferred --->
    <script defer webc:keep src="/assets/js/analytics.js"></script>

    <!--- Text Scramble Effect - Deferred --->
    <script defer webc:keep src="/assets/js/text-scramble.js"></script>

    <!--- Holographic 3D Effect - Deferred --->
    <script defer webc:keep src="/assets/js/holographic-effect.js"></script>

    <!--- UnicornStudio SDK - loaded in head for faster rendering --->
    <script webc:raw type="text/javascript">
      !(function () {
        // Check for WebGL support before loading UnicornStudio
        function hasWebGLSupport() {
          try {
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            return !!gl;
          } catch (e) {
            return false;
          }
        }

        // Initialize UnicornStudio after DOM is ready
        function initUnicornStudio() {
          try {
            if (
              window.UnicornStudio &&
              typeof UnicornStudio.init === 'function' &&
              !window.UnicornStudio.isInitialized
            ) {
              UnicornStudio.init();
              window.UnicornStudio.isInitialized = true;
              window.UnicornStudio.isReady = true;
              // Dispatch event to signal UnicornStudio is ready
              window.dispatchEvent(new CustomEvent('unicornStudioReady'));
            }
          } catch (e) {
            console.warn('UnicornStudio initialization failed:', e.message);
          }
        }

        if (!window.UnicornStudio && hasWebGLSupport()) {
          window.UnicornStudio = { isInitialized: false, isReady: false };
          var i = document.createElement('script');
          i.src =
            'https://cdn.jsdelivr.net/gh/hiunicornstudio/unicornstudio.js@v1.4.34/dist/unicornStudio.umd.js';
          i.onload = function () {
            // Wait for DOM to be ready before initializing
            if (document.readyState === 'loading') {
              document.addEventListener('DOMContentLoaded', initUnicornStudio);
            } else {
              // DOM is already ready - add small delay to ensure elements are fully rendered
              setTimeout(initUnicornStudio, 100);
            }
          };
          i.onerror = function () {
            console.warn('Failed to load UnicornStudio SDK');
          };
          (document.head || document.body).appendChild(i);
        }
      })();
    </script>

    <!--- Axe-core for accessibility testing (development only) --->
    <script webc:if="env !== 'production'" webc:keep src="/assets/js/axe-core.js"></script>

    <script async webc:keep src="https://www.googletagmanager.com/gtag/js?id=G-3BCTP3WC02"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'G-3BCTP3WC02');
    </script>
  </head>

  <body
    class="flex min-h-screen flex-col text-zinc-400 antialiased selection:bg-zinc-800 selection:text-zinc-100"
  >
    <div
      class="aura-background-component fixed top-0 left-0 -z-10 h-screen w-full"
      data-alpha-mask="80"
      style="
        mask-image: linear-gradient(to bottom, transparent, black 0%, black 80%, transparent);
        -webkit-mask-image: linear-gradient(
          to bottom,
          transparent,
          black 0%,
          black 80%,
          transparent
        );
      "
    >
      <div
        data-us-project="0WrRbFIPaKoWVkiQWBG0"
        data-us-production="true"
        data-us-scale="0.75"
        data-us-dpi="1.5"
        data-us-fps="60"
        data-us-alttext="Animated background scene"
        data-us-arialabel="Decorative animated background"
        class="absolute top-0 left-0 -z-10 h-full w-full"
      ></div>
    </div>

    <div
      id="page-transition"
      class="pointer-events-none fixed inset-0 z-40 bg-black opacity-0 transition-opacity duration-500"
    ></div>

    <div
      class="relative mx-auto flex min-h-screen w-full max-w-[1400px] flex-col border-x border-white/10 bg-[#08090A]/40"
    >
      <site-header :base="base" :navigation="navigation"></site-header>
      <main
        id="main-content"
        class="relative grid grow grid-cols-1 divide-y divide-white/10 md:grid-cols-12 md:divide-x md:divide-y-0"
        @html="this.content"
      ></main>
      <site-footer :base="base"></site-footer>
    </div>

    <!--- Motion Library - Lightweight animation utility --->
    <script defer webc:keep src="/assets/js/motion.js"></script>
    <script defer @raw="getBundle('js')" webc:keep></script>

    <!-- Lucide Icons - Deferred -->
    <script defer webc:keep src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    <script defer webc:keep>
      // Initialize Lucide icons when the library loads
      function initLucideIcons() {
        if (window.lucide && typeof lucide.createIcons === 'function') {
          lucide.createIcons();
        } else {
          // Retry if lucide hasn't loaded yet
          setTimeout(initLucideIcons, 50);
        }
      }

      // Start initialization
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initLucideIcons);
      } else {
        initLucideIcons();
      }
    </script>

    <script webc:raw type="text/javascript">
      // Page Transition System using View Transitions API + Motion library
      class PageTransition {
        constructor() {
          this.transition = document.getElementById('page-transition');
          this.mainContent = document.getElementById('main-content');
          this.isTransitioning = false;

          // Check if View Transitions API is supported
          this.supportsViewTransitions = 'startViewTransition' in document;

          this.init();
        }

        init() {
          // Handle initial page load
          this.handleInitialLoad();

          // Handle navigation clicks
          this.handleNavigation();

          // Handle browser back/forward
          this.handleBrowserNavigation();
        }

        handleInitialLoad() {
          // Show content with subtle animations on initial page load
          // Wait for UnicornStudio to be ready before animating content
          const startAnimations = () => {
            requestAnimationFrame(() => {
              this.showContent();
            });
          };

          if (window.UnicornStudio && !window.UnicornStudio.isReady) {
            // Wait for UnicornStudio to initialize
            const timeout = setTimeout(startAnimations, 1500);
            window.addEventListener(
              'unicornStudioReady',
              () => {
                clearTimeout(timeout);
                // Small delay after UnicornStudio is ready
                setTimeout(startAnimations, 100);
              },
              { once: true }
            );
          } else {
            // UnicornStudio already loaded or not needed
            startAnimations();
          }
        }

        showContent() {
          if (this.mainContent) {
            // Animate content elements with stagger
            this.animateContentElements();
          }
        }

        animateContentElements() {
          // Wait for Motion library to load
          if (!window.Motion) {
            setTimeout(() => this.animateContentElements(), 50);
            return;
          }

          // Try to identify split columns for concurrent animation
          const mainCol = this.mainContent.querySelector('.md\\:col-span-9');
          const sideCol = this.mainContent.querySelector('.md\\:col-span-3');

          // Broad selector for text and card elements
          const selector = 'h1, h2, h3, h4, p, li, span.text-xs, .card, .project-card, .group';

          // Use subtle animations - less movement and blur
          const animConfig = {
            opacity: 1,
            y: 0,
            filter: 'blur(0px)',
            duration: 0.5,
            stagger: 0.02,
            ease: 'power2.out',
            delay: 0,
          };

          const fromConfig = {
            opacity: 0,
            y: 8,
            filter: 'blur(4px)',
          };

          if (mainCol && sideCol) {
            // Two-column layout: Animate concurrently
            const mainElements = mainCol.querySelectorAll(selector);
            const sideElements = sideCol.querySelectorAll(selector);

            if (mainElements.length > 0) {
              Motion.fromTo(mainElements, fromConfig, animConfig);
            }

            if (sideElements.length > 0) {
              Motion.fromTo(sideElements, fromConfig, {
                ...animConfig,
                delay: 0.05, // Slight offset from main content
              });
            }
          } else {
            // Single column / Fallback
            const elements = this.mainContent.querySelectorAll(selector);
            if (elements.length > 0) {
              Motion.fromTo(elements, fromConfig, animConfig);
            }
          }
        }

        handleNavigation() {
          // Intercept all internal links
          document.addEventListener('click', (e) => {
            const link = e.target.closest('a[href]');
            if (!link) return;

            const href = link.getAttribute('href');

            // Handle home link - prevent reload if already on home page
            if (link.id === 'home-link') {
              const isHomePage =
                window.location.pathname === '/' || window.location.pathname === '/index.html';
              if (isHomePage) {
                e.preventDefault();
                window.scrollTo({ top: 0, behavior: 'smooth' });
                return;
              }
            }

            // Handle hash links (e.g., /#about or #about)
            if (href && href.includes('#')) {
              const [path, hash] = href.split('#');

              // If navigating to same page with hash (empty path or current path or home path when on home)
              const isCurrentPage = path === '' || path === window.location.pathname;
              const isHomePage =
                window.location.pathname === '/' || window.location.pathname === '/index.html';
              const isHomeLink = path === '/' || path === '';

              if (isCurrentPage || (isHomeLink && isHomePage)) {
                // Same page navigation - just scroll
                e.preventDefault();
                const targetElement = document.getElementById(hash);
                if (targetElement) {
                  targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
                // Update URL without reloading
                if (window.location.hash !== '#' + hash) {
                  history.pushState({}, '', href);
                }
                return;
              } else if (path === '/' || (path === '' && !isHomePage)) {
                // Navigating to home page with hash from a different page
                e.preventDefault();
                this.navigateToHash('/', hash);
                return;
              }
            }

            // Check if it's an internal link (not external, not hash-only, not mailto/tel)
            if (
              href &&
              !href.startsWith('http') &&
              !href.startsWith('#') &&
              !href.startsWith('mailto:') &&
              !href.startsWith('tel:') &&
              !link.hasAttribute('download')
            ) {
              e.preventDefault();
              this.navigateTo(href);
            }
          });
        }

        handleBrowserNavigation() {
          // Handle browser back/forward buttons
          window.addEventListener('popstate', (e) => {
            if (e.state && e.state.url) {
              this.navigateTo(e.state.url, false);
            }
          });
        }

        async navigateToHash(url, hash) {
          if (this.isTransitioning) return;
          this.isTransitioning = true;

          try {
            // Use View Transitions API if supported
            if (this.supportsViewTransitions) {
              const transition = document.startViewTransition(async () => {
                // Fetch new page content
                const response = await fetch(url);
                const html = await response.text();

                // Parse the HTML to get just the content area
                const parser = new DOMParser();
                const newDoc = parser.parseFromString(html, 'text/html');
                const newContent = newDoc.querySelector('#main-content');

                if (newContent) {
                  // Update page title
                  const newTitle = newDoc.querySelector('title');
                  if (newTitle) {
                    document.title = newTitle.textContent;
                  }

                  // Update URL with hash
                  const fullUrl = url + '#' + hash;
                  history.pushState({ url: fullUrl }, '', fullUrl);

                  // Replace content
                  this.mainContent.innerHTML = newContent.innerHTML;

                  // Update any scripts or dynamic content
                  this.updateDynamicContent();
                }
              });

              await transition.finished;

              // Animate content elements after transition
              requestAnimationFrame(() => {
                this.animateContentElements();
              });

              // Scroll to the target element after content is loaded
              setTimeout(() => {
                const targetElement = document.getElementById(hash);
                if (targetElement) {
                  targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
              }, 100);
            } else {
              // Fallback for browsers without View Transitions API
              await this.navigateToHashFallback(url, hash);
            }
          } catch (error) {
            console.error('Navigation error:', error);
            // Fallback to normal navigation
            window.location.href = url + '#' + hash;
          } finally {
            this.isTransitioning = false;
          }
        }

        async navigateToHashFallback(url, hash) {
          // Show transition overlay
          this.showTransition();

          // Fetch new page content
          const response = await fetch(url);
          const html = await response.text();

          // Parse the HTML to get just the content area
          const parser = new DOMParser();
          const newDoc = parser.parseFromString(html, 'text/html');
          const newContent = newDoc.querySelector('#main-content');

          if (newContent) {
            // Update page title
            const newTitle = newDoc.querySelector('title');
            if (newTitle) {
              document.title = newTitle.textContent;
            }

            // Update URL with hash
            const fullUrl = url + '#' + hash;
            history.pushState({ url: fullUrl }, '', fullUrl);

            // Animate out current content
            await this.animateOutContent();

            // Replace content
            this.mainContent.innerHTML = newContent.innerHTML;

            // Animate in new content
            await this.animateInContent();

            // Update any scripts or dynamic content
            this.updateDynamicContent();

            // Scroll to the target element after content is loaded
            setTimeout(() => {
              const targetElement = document.getElementById(hash);
              if (targetElement) {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }
            }, 100);
          }

          this.hideTransition();
        }

        async navigateTo(url, addToHistory = true) {
          if (this.isTransitioning) return;
          this.isTransitioning = true;

          try {
            // Use View Transitions API if supported
            if (this.supportsViewTransitions) {
              const transition = document.startViewTransition(async () => {
                // Fetch new page content
                const response = await fetch(url);
                const html = await response.text();

                // Parse the HTML to get just the content area
                const parser = new DOMParser();
                const newDoc = parser.parseFromString(html, 'text/html');
                const newContent = newDoc.querySelector('#main-content');

                if (newContent) {
                  // Update page title
                  const newTitle = newDoc.querySelector('title');
                  if (newTitle) {
                    document.title = newTitle.textContent;
                  }

                  // Update URL
                  if (addToHistory) {
                    history.pushState({ url: url }, '', url);
                  }

                  // Replace content
                  this.mainContent.innerHTML = newContent.innerHTML;

                  // Reset scroll position to top
                  window.scrollTo(0, 0);

                  // Update any scripts or dynamic content
                  this.updateDynamicContent();
                }
              });

              await transition.finished;

              // After transition completes, add subtle entrance animations
              // Use a small delay to ensure DOM is ready
              requestAnimationFrame(() => {
                this.animateContentElements();
              });
            } else {
              // Fallback for browsers without View Transitions API
              await this.navigateToFallback(url, addToHistory);
            }
          } catch (error) {
            console.error('Navigation error:', error);
            // Fallback to normal navigation
            window.location.href = url;
          } finally {
            this.isTransitioning = false;
          }
        }

        async navigateToFallback(url, addToHistory = true) {
          // Show transition overlay
          this.showTransition();

          // Fetch new page content
          const response = await fetch(url);
          const html = await response.text();

          // Parse the HTML to get just the content area
          const parser = new DOMParser();
          const newDoc = parser.parseFromString(html, 'text/html');
          const newContent = newDoc.querySelector('#main-content');

          if (newContent) {
            // Update page title
            const newTitle = newDoc.querySelector('title');
            if (newTitle) {
              document.title = newTitle.textContent;
            }

            // Update URL
            if (addToHistory) {
              history.pushState({ url: url }, '', url);
            }

            // Animate out current content
            await this.animateOutContent();

            // Replace content
            this.mainContent.innerHTML = newContent.innerHTML;

            // Reset scroll position to top
            window.scrollTo(0, 0);

            // Animate in new content
            await this.animateInContent();

            // Update any scripts or dynamic content
            this.updateDynamicContent();
          }

          // Hide transition overlay
          this.hideTransition();
        }

        showTransition() {
          if (this.transition && window.Motion) {
            Motion.to(this.transition, {
              opacity: 1,
              duration: 0.3,
              ease: 'power2.inOut',
            });
          }
        }

        hideTransition() {
          if (this.transition && window.Motion) {
            Motion.to(this.transition, {
              opacity: 0,
              duration: 0.5,
              ease: 'power2.inOut',
            });
          }
        }

        animateOutContent() {
          if (!window.Motion) return Promise.resolve();

          return Motion.to(this.mainContent, {
            opacity: 0,
            y: -20,
            duration: 0.4,
            ease: 'power2.in',
          });
        }

        animateInContent() {
          if (!window.Motion) return Promise.resolve();

          return new Promise((resolve) => {
            // Start content animation immediately
            this.animateContentElements();

            // Fade in the container (shell/backgrounds) quickly
            Motion.fromTo(
              this.mainContent,
              {
                opacity: 0,
                y: 0,
              },
              {
                opacity: 1,
                y: 0,
                duration: 0.3,
                ease: 'power2.out',
                onComplete: resolve,
              }
            );
          });
        }

        updateDynamicContent() {
          // Re-initialize any dynamic content like carousels, animations, etc.
          // This can be extended based on what dynamic elements you have

          // Re-initialize Lucide icons
          if (window.lucide && typeof lucide.createIcons === 'function') {
            lucide.createIcons();
          }

          // Re-initialize UnicornStudio if present
          if (
            window.UnicornStudio &&
            window.UnicornStudio.isReady &&
            typeof UnicornStudio.init === 'function'
          ) {
            try {
              // Small delay to ensure DOM is ready
              setTimeout(() => {
                UnicornStudio.init();
              }, 100);
            } catch (e) {
              console.warn('UnicornStudio re-initialization failed:', e.message);
            }
          }

          // Dispatch custom event for other scripts to listen to
          window.dispatchEvent(new CustomEvent('pageTransitionComplete'));
        }
      }

      // Initialize when DOM is ready and Motion library is loaded
      function initPageTransition() {
        if (window.Motion) {
          new PageTransition();
        } else {
          // Wait for Motion library to load
          setTimeout(initPageTransition, 50);
        }
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initPageTransition);
      } else {
        initPageTransition();
      }
    </script>
  </body>
</html>
